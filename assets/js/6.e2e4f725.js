(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{241:function(t,n,a){"use strict";a.r(n);var e=a(14),s=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"学习-c-核心"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#学习-c-核心"}},[t._v("#")]),t._v(" 学习[c++ 核心]")]),t._v(" "),n("h2",{attrs:{id:"内存分区模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存分区模型"}},[t._v("#")]),t._v(" 内存分区模型")]),t._v(" "),n("p",[t._v("c++程序在执行时，将内存方向划分为4个区域")]),t._v(" "),n("ul",[n("li",[t._v("代码区：存放函数体的二进制代码，由操作系统进行管理")]),t._v(" "),n("li",[t._v("全局区：存放全局变量和静态变量，常量")]),t._v(" "),n("li",[t._v("栈区：由编译器自动分配释放，存放函数的参数值，局部变量等")]),t._v(" "),n("li",[t._v("堆区；由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收")])]),t._v(" "),n("p",[n("em",[n("strong",[t._v("内存四区的意义： 不同区域存放的数据，赋予不同的生命周期，给我们更方便的灵活编程")])])]),t._v(" "),n("h3",{attrs:{id:"程序执行前"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#程序执行前"}},[t._v("#")]),t._v(" 程序执行前")]),t._v(" "),n("p",[t._v("在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域")]),t._v(" "),n("p",[n("em",[n("strong",[t._v("代码区：")])])]),t._v(" "),n("ul",[n("li",[n("em",[t._v("存放CPU执行的机器指令")])]),t._v(" "),n("li",[t._v("代码区使共享的，共享的目的是对于频繁的被执行程序，只需要在内存中有一份代码即可")]),t._v(" "),n("li",[t._v("代码区是只读的，使其只读的原因是为了防止程序意外地修改了他的指令")])]),t._v(" "),n("p",[n("em",[n("strong",[t._v("全局区：")])])]),t._v(" "),n("ul",[n("li",[n("em",[t._v("全局变量和静态变量存放于此")])]),t._v(" "),n("li",[t._v("全局区还包含了常量区，字符串常量和其他常量也存放于此，")]),t._v(" "),n("li",[t._v("该区域的数据在程序结束后由操作系统释放")])]),t._v(" "),n("h3",{attrs:{id:"栈区"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈区"}},[t._v("#")]),t._v(" 栈区")]),t._v(" "),n("ul",[n("li",[t._v("形参 和 局部变量存放于此")]),t._v(" "),n("li",[n("em",[t._v("注意：不要返回栈区的地址，因为栈区的内存会在使用一次后被释放")])])]),t._v(" "),n("h3",{attrs:{id:"堆区"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#堆区"}},[t._v("#")]),t._v(" 堆区")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('int* func()\n{\t\t\t\t\t\t// 利用new关键字，可以将数据开辟到堆区\n\tint* p = new int(10); // 指针本质上是一个局部变量，放在栈上\n\treturn p;\t\t\t // 指针保存的数据放在堆区\n}\n\nint main() {\n\n\tint* p = func();\n\n\tcout << *p << endl;\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),n("h3",{attrs:{id:"new关键字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new关键字"}},[t._v("#")]),t._v(" new关键字")]),t._v(" "),n("p",[t._v("堆区开辟的地址，由程序员手动释放，释放利用操作符delete")]),t._v(" "),n("h2",{attrs:{id:"引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[t._v("#")]),t._v(" 引用")]),t._v(" "),n("p",[t._v("给变量起别名")]),t._v(" "),n("h3",{attrs:{id:"语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),n("p",[t._v("数据类型 &别名 = 原名")]),t._v(" "),n("p",[n("em",[t._v("注意：引用必须初始化， 引用在初始化后就不可以发生改变")])]),t._v(" "),n("h3",{attrs:{id:"引用做函数参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用做函数参数"}},[t._v("#")]),t._v(" 引用做函数参数")]),t._v(" "),n("p",[t._v("复习：参数传递有两种方式，")]),t._v(" "),n("ol",[n("li",[t._v("值传递")]),t._v(" "),n("li",[t._v("地址传递")])]),t._v(" "),n("p",[t._v("引用传递：")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('void mySwap03(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\n\n\tcout << "引用传递:" << endl;\n\tmySwap03(a, b);\n\tcout << "a = " << a << endl;\n\tcout << "b = " << b << endl;\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),n("h3",{attrs:{id:"引用做函数返回值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用做函数返回值"}},[t._v("#")]),t._v(" 引用做函数返回值")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('int& test01() {\n\tstatic int a = 10; // 可以在变量前加上static关键字将数据存放到堆区\n\treturn a;\n}\n\nint main() {\n\n\tint& b = test01();\n\tcout << b << endl;\n\tcout << b << endl;\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),n("p",[n("em",[t._v("注意：如果函数的返回值是引用，则这个函数调用可以作为左值")])]),t._v(" "),n("h3",{attrs:{id:"引用的本质"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用的本质"}},[t._v("#")]),t._v(" 引用的本质")]),t._v(" "),n("p",[t._v("引用的本质在c++内部实现是一个指针常量")]),t._v(" "),n("h3",{attrs:{id:"常量引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常量引用"}},[t._v("#")]),t._v(" 常量引用")]),t._v(" "),n("p",[t._v("用来修饰形参，防止误操作")]),t._v(" "),n("h2",{attrs:{id:"函数提高"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数提高"}},[t._v("#")]),t._v(" 函数提高")]),t._v(" "),n("h3",{attrs:{id:"函数的默认参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数的默认参数"}},[t._v("#")]),t._v(" 函数的默认参数")]),t._v(" "),n("p",[t._v("数据类型 函数名（参数 = 默认值）{")]),t._v(" "),n("p",[t._v("}")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include<iostream>\nusing namespace std;\n\nint func(int a  , int c ,int b = 10 ) {\n\treturn a + c + b;\n}\n\n\n\nint main() {\n\n\tcout << func(10,20) << endl;\n\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),n("p",[n("em",[t._v("注意：附加默认参数的参数要写在实际参数的后面")])]),t._v(" "),n("p",[n("em",[t._v("注意：如果函数声明有默认参数，函数实现就不能有默认参数")])]),t._v(" "),n("h3",{attrs:{id:"函数占位参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数占位参数"}},[t._v("#")]),t._v(" 函数占位参数")]),t._v(" "),n("p",[t._v("在参数中传入数据类型，当作一个占位参数")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include<iostream>\nusing namespace std;\n\nvoid fn(int a,string) {\n\t\t\n\tcout << "this is fn" << endl;\n}\n\nint main() {\n\n\tfn(10, "10");\n\t\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),n("h3",{attrs:{id:"函数重载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数重载"}},[t._v("#")]),t._v(" 函数重载")]),t._v(" "),n("p",[t._v("作用：函数名可以相同，提高重复性")]),t._v(" "),n("p",[n("em",[n("strong",[t._v("函数重载满足的条件：")])])]),t._v(" "),n("ul",[n("li",[t._v("同一个作用域下")]),t._v(" "),n("li",[t._v("函数名称相同")]),t._v(" "),n("li",[n("em",[n("strong",[t._v("函数参数类型不同，或者个数不同 或者顺序不同")])])])]),t._v(" "),n("p",[n("em",[t._v("注意：函数的返回值不可以作为函数重载的条件")])]),t._v(" "),n("h3",{attrs:{id:"函数重载碰到默认参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数重载碰到默认参数"}},[t._v("#")]),t._v(" 函数重载碰到默认参数")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('void func() {\n\tcout << "func" << endl;\n}\n\nvoid func(int a) {\n\tcout << "func (int a)" << endl;\n}\n\nint main() {\n\n\tfunc(10);\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('void func(int &a) {\t\t\t\t//当传入的参数是一个常量时，参数不能\t\t\t\t\t\t\t\t\t\t为引用参数\n\tcout << "func" << endl;\n}\n\nvoid func(const int &a) {\t// 所以当传入常量时，函数重载的目标函\t\t\t\t\t\t\t\t\t数将会是参数为常量引用的函数\n\tcout << "func (int a)" << endl;\n}\n\n\n\nint main() {\n\n\tfunc(10);\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),n("p",[n("em",[t._v("注意：当函数重载碰到默认参数，会出现二义性")])]),t._v(" "),n("h2",{attrs:{id:"类和对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类和对象"}},[t._v("#")]),t._v(" 类和对象")]),t._v(" "),n("h3",{attrs:{id:"三大特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三大特性"}},[t._v("#")]),t._v(" 三大特性")]),t._v(" "),n("ul",[n("li",[t._v("封装")]),t._v(" "),n("li",[t._v("继承")]),t._v(" "),n("li",[t._v("多态")])]),t._v(" "),n("h3",{attrs:{id:"封装的意义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#封装的意义"}},[t._v("#")]),t._v(" 封装的意义")]),t._v(" "),n("ol",[n("li",[t._v("public")]),t._v(" "),n("li",[t._v("protected")]),t._v(" "),n("li",[t._v("private")])]),t._v(" "),n("h3",{attrs:{id:"struct-和-class-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#struct-和-class-的区别"}},[t._v("#")]),t._v(" struct 和 class 的区别")]),t._v(" "),n("p",[t._v("struct的默认权限是公共， class默认权限是私有")]),t._v(" "),n("h3",{attrs:{id:"类的分文件编写"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类的分文件编写"}},[t._v("#")]),t._v(" 类的分文件编写")]),t._v(" "),n("p",[t._v("首先创建 头文件 xxx.h")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("#pragma once\n#include <iostream>\nusing namespace std;\n\nclass Point {\npublic:\n\tvoid setX(int x);\n\tint getX();\n\tvoid setY(int y);\n\tint getY();\nprivate:\n\tint m_X;\n\tint m_Y;\n};// 在头文件中，只写入函数声明，不包含具体的函数实现\n")])])]),n("p",[t._v("再创建源文件 xxx.cpp")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include"point.h" //首先引入刚刚编写的头文件\n\nvoid Point::setX(int x) {\n\tm_X = x;\n}\nint Point::getX() {\n\treturn m_X;\n}\nvoid Point::setY(int y) {\n\tm_Y = y;\n}\nint Point::getY() {\n\treturn m_Y;\n}// 放入有关函数的具体实现 ， 并在每个函数前加上此函数的作用域 Point::\n')])])]),n("p",[t._v("最后，在源文件中引入需要用到的类的头文件")]),t._v(" "),n("p",[n("em",[t._v("注意：如果要在一个类文件中使用另一个类文件，那么也需要在头文件中引入另一个类文件的头文件。")])]),t._v(" "),n("h3",{attrs:{id:"对象的初始化和清理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对象的初始化和清理"}},[t._v("#")]),t._v(" 对象的初始化和清理")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("构造函数")]),t._v(" "),n("ol",[n("li",[t._v("构造函数没有返回值，也不写void")]),t._v(" "),n("li",[t._v("函数名称与类名相同")]),t._v(" "),n("li",[t._v("构造函数可以有参数，可以发生重载")]),t._v(" "),n("li",[t._v("程序在***调用***对象时会自动调用构造，无需手动调用，而且只会调用一次")])])]),t._v(" "),n("li",[n("p",[t._v("析构函数")]),t._v(" "),n("ol",[n("li",[t._v("没有返回值，不屑void")]),t._v(" "),n("li",[t._v("在名称前加上~")]),t._v(" "),n("li",[t._v("不可以有参数，不可以发生重载")]),t._v(" "),n("li",[t._v("程序在***销毁***对象时会自动调用构造，无需手动调用，而且只会调用一次")])])])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class Person {\npublic:\n\tPerson(){\n\t\tcout << "这是构造函数" << endl;\n\t}\n\n\t~Person() {\n\t\tcout << "这是析构函数" << endl;\n\t}\n\n};\n')])])]),n("h3",{attrs:{id:"构造函数的分类和调用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造函数的分类和调用"}},[t._v("#")]),t._v(" 构造函数的分类和调用")]),t._v(" "),n("p",[t._v("两种分类方式")]),t._v(" "),n("ul",[n("li",[t._v("按参数分为：有参构造 "),n("code",[t._v("Person(int a)")]),t._v(" 和无参构造 "),n("code",[t._v("Person()")])]),t._v(" "),n("li",[t._v("按类型分为：普通构造和拷贝构造 "),n("code",[t._v("Person( const Person &p )")])])]),t._v(" "),n("p",[t._v("三种调用方式")]),t._v(" "),n("ul",[n("li",[t._v("括号法")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('void test01() {\n\n\t//1.括号法调用\n\n\tPerson p1;  // 调用默认构造函数时，不要加括号,因为编译器会认为这是一个函数的声明\n\n\tPerson p2(10);\n\n\tPerson p3(p2);\n\n\tcout << "p2的年龄为： " << p2.age << endl;\n\tcout << "p3的年龄为： " << p3.age << endl;\n\n}\n')])])]),n("ul",[n("li",[t._v("显示法")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Person p1;\n\n\tPerson p2 = Person(10); // Person(10) 为匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象\n\n\tPerson p3 = Person(p2);//注意，不要用拷贝构造函数初始化匿名对象\n")])])]),n("ul",[n("li",[t._v("隐式转换法")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t//3.隐式转换法调用\n\tPerson p4 = 10; //有参构造\n\tPerson p5 = p4;\n\n")])])]),n("h3",{attrs:{id:"拷贝构造函数的调用时机"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#拷贝构造函数的调用时机"}},[t._v("#")]),t._v(" 拷贝构造函数的调用时机")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("使用一个已创建完毕的对象来初始化一个新对象")])]),t._v(" "),n("li",[n("p",[t._v("值传递的方式给娴熟参数传值")])]),t._v(" "),n("li",[n("p",[t._v("以值方式返回局部对象")])])]),t._v(" "),n("h3",{attrs:{id:"构造函数的调用规则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造函数的调用规则"}},[t._v("#")]),t._v(" 构造函数的调用规则")]),t._v(" "),n("p",[t._v("只要写一个类，c++编译器 至少给一个类添加三个函数")]),t._v(" "),n("ol",[n("li",[t._v("默认构造函数")]),t._v(" "),n("li",[t._v("默认析构函数")]),t._v(" "),n("li",[t._v("默认拷贝函数")])]),t._v(" "),n("p",[t._v("构造函数规则如下：")]),t._v(" "),n("ul",[n("li",[t._v("如果用户定义有参构造函数， c++不再提供默认无参构造函数 但是会提供默认拷贝函数")]),t._v(" "),n("li",[t._v("如果用户定义拷贝构造函数， c++不会再提供其他构造函数")])]),t._v(" "),n("h3",{attrs:{id:"浅拷贝与深拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝与深拷贝"}},[t._v("#")]),t._v(" "),n("em",[n("strong",[t._v("浅拷贝与深拷贝")])])]),t._v(" "),n("p",[t._v("浅拷贝：简单的赋值拷贝操作")]),t._v(" "),n("p",[t._v("深拷贝：在堆区重新申请空间，进行拷贝操作")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include<iostream>\nusing namespace std;\n#include<string>\n\nclass Person {\npublic:\n\tint m_age;\n\tint *m_Height;\n\n\tPerson() {\n\t\tcout << "无参构造函数" << endl;\n\t}\n\n\tPerson(int a , int height) {\n\t\tcout << "有参构造函数" << endl;\n\t\tm_age = a;\n\t\tm_Height = new int(height); // 利用new把 height创建在堆区 ， 此时返回的是一个指针，指向m_Height存储的数据\n\t}\n\n\t//自己实现一个拷贝构造函数，解决浅拷贝带来的问题\n\tPerson(const Person& p) {\n\t\tcout << "Person拷贝构造函数的调用" << endl;\n\t\tm_age = p.m_age;\n\n\t\tm_Height = new int(*p.m_Height);\n\t}\n\n\t~Person() {\n\t\t//析构代码，将堆区开辟的数据做释放操作\n\t\tif (m_Height != NULL) {\n\t\t\tdelete m_Height;\n\t\t\tm_Height = NULL;\n\t\t}\n\t\tcout << "析构函数" << endl;\n\t}\n};\n \nvoid test01() {\n\n\tPerson p1(20 , 160);\n\n\tcout << "p1的年龄为： " << p1.m_age << "身高为： " << *p1.m_Height << endl;\n\n\tPerson p2(p1);\n\n\tcout << "p2的年龄为： " << p2.m_age << "身高为： " << *p2.m_Height << endl;\n\n}\n\nint main() {\n\n\ttest01();\n\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),n("p",[n("em",[n("strong",[t._v("总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题")])])]),t._v(" "),n("h3",{attrs:{id:"初始化列表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初始化列表"}},[t._v("#")]),t._v(" 初始化列表")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class Person {\n\npublic:\n\tint m_A;\n\tint m_B;\n\tint m_C;\n// 设置形参\n\tPerson(int a, int b ,int c) :m_A(a), m_B(b), m_C(c) {\n\t\tcout << "初始化别表" << endl;\n\t}\n\n};\n\nvoid test01() {\n\n\tPerson p1(30, 20, 10);//初始化列表的语法，传入参数\n\t\n}\n')])])]),n("h3",{attrs:{id:"类对象作为类成员"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类对象作为类成员"}},[t._v("#")]),t._v(" 类对象作为类成员")]),t._v(" "),n("p",[t._v("当有其他类作为本类的成员时，先创建其他类，在创建本类。")]),t._v(" "),n("p",[t._v("而在析构时，会执行本类的析构函数，在执行其他类。")]),t._v(" "),n("h3",{attrs:{id:"静态成员"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#静态成员"}},[t._v("#")]),t._v(" 静态成员")]),t._v(" "),n("p",[t._v("静态成员就是在成员变量和成员函数前加上关键字static，成为静态成员。")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("静态成员变量")]),t._v(" "),n("ul",[n("li",[t._v("所有对象共享同一份数据")]),t._v(" "),n("li",[t._v("在编译阶段分配内存")]),t._v(" "),n("li",[t._v("类内声明，类外初始化")]),t._v(" "),n("li",[t._v("访问方式：通过对象，或通过类名来访问")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Person {\n\npublic:\n\n\tstatic int m_A;\n\n};\nint Person::m_A = 100;\n\nvoid test01() {\n\tPerson p1;\n\tcout << p1.m_A << endl; //通过属性来访问\n\n\tcout << Person::m_A << endl;//通过类名来访问\n}\n")])])])]),t._v(" "),n("li",[n("p",[t._v("静态成员函数")]),t._v(" "),n("ul",[n("li",[n("em",[n("strong",[t._v("只能访问静态成员对象")])])]),t._v(" "),n("li",[t._v("所有对象都共享同一个函数")]),t._v(" "),n("li",[t._v("访问方式：通过对象，通过类名")])])])]),t._v(" "),n("h3",{attrs:{id:"c-对象模型和this指针"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#c-对象模型和this指针"}},[t._v("#")]),t._v(" c++对象模型和this指针")]),t._v(" "),n("h4",{attrs:{id:"成员变量和成员函数是分开存储的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#成员变量和成员函数是分开存储的"}},[t._v("#")]),t._v(" 成员变量和成员函数是分开存储的")]),t._v(" "),n("p",[t._v("只有非静态成员对象属于类的对象上")]),t._v(" "),n("h4",{attrs:{id:"this-指针"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-指针"}},[t._v("#")]),t._v(" this 指针")]),t._v(" "),n("p",[t._v("this 指针指向被调用的成员函数所属的对象")]),t._v(" "),n("ul",[n("li",[t._v("this指针是隐含每一个非静态成员函数内的一种指针")]),t._v(" "),n("li",[t._v("this指针不需要定义直接使用即可")])]),t._v(" "),n("p",[t._v("this指针的用途")]),t._v(" "),n("ul",[n("li",[t._v("当形参和成员变量同名时，可用this指针来区分")]),t._v(" "),n("li",[t._v("在类的非静态成员函数中返回对象本身，可使用return *this")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include<iostream>\nusing namespace std;\n#include<string>\n\nclass Person {\n\npublic:\n\n\tint age;\n\n\tPerson(int age) {\n\t\tthis->age = age; //this指针指向被调用成员函数所属的对象\n\t}\n\n\tPerson& addAge(Person& p) {  \n        // 当返回值是解指针,返回本体时，要用引用的方式接收数据\n\n\t\tthis->age += p.age;\n\n\t\treturn *this;\n\t}\n};\n\nvoid test02() {\n\n\tPerson p2(10);\n\n\tPerson p3(20);\n\n\tp3.addAge(p2).addAge(p2);\n\tcout << "p3的年龄为： " << p3.age << endl;\n}\n\nint main() {\n\n\ttest02();\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),n("h3",{attrs:{id:"空指针访问成员函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#空指针访问成员函数"}},[t._v("#")]),t._v(" 空指针访问成员函数")]),t._v(" "),n("p",[t._v("无法访问成员中的属性")]),t._v(" "),n("h3",{attrs:{id:"运算符重载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#运算符重载"}},[t._v("#")]),t._v(" 运算符重载")]),t._v(" "),n("p",[t._v("只能利用全局函数重载左移运算符")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class Person {\n\tfriend ostream& operator<<(ostream& cout, Person& p);\npublic:\n\tPerson(int a, int b) {\n\t\tm_A = a;\n\t\tm_B = b;\n\t}\n\nprivate:\n\n\tint m_A;\n\tint m_B;\n\n};\n\nostream & operator<<(ostream &cout,Person & p) {\n\tcout << "m_A = " << p.m_A << "m_B = " << p.m_B; \n\treturn cout;\n}\n\nvoid test02() {\n\tPerson p(10, 20);\n\tcout << p << endl;\n}\n')])])]),n("h3",{attrs:{id:"递增运算符重载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#递增运算符重载"}},[t._v("#")]),t._v(" 递增运算符重载")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class MyInteger{\n\tfriend ostream& operator<<(ostream& cout, MyInteger myint);\npublic:\n\tMyInteger() {\n\t\tm_Num = 0;\n\t}\n\n\t//重载前置运算符\n\tMyInteger& operator++() {  //返回引用是为了可以修改实参\n\t\t++m_Num;\n\t\treturn *this;\n\t}\n\n\tMyInteger operator++(int) {  //传入int占位参数，可以区分前置和后置递增\n\tMyInteger temp = *this;\n\t\t++m_Num;\n\t\treturn temp;\n\t}\n")])])]),n("h3",{attrs:{id:"赋值运算符重载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#赋值运算符重载"}},[t._v("#")]),t._v(" 赋值运算符重载")]),t._v(" "),n("p",[t._v("为解决深浅拷贝问题，要手动写入深拷贝代码，并返回自身可以实现链式调用")]),t._v(" "),n("h3",{attrs:{id:"关系运算符重载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关系运算符重载"}},[t._v("#")]),t._v(" 关系运算符重载")]),t._v(" "),n("h3",{attrs:{id:"函数调用运算符重载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数调用运算符重载"}},[t._v("#")]),t._v(" 函数调用运算符重载")]),t._v(" "),n("h2",{attrs:{id:"继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),n("h3",{attrs:{id:"构造和析构的顺序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造和析构的顺序"}},[t._v("#")]),t._v(" 构造和析构的顺序")]),t._v(" "),n("p",[t._v("遵循栈的数据规则，后进先出，构造函数的打印顺序与析构函数顺序相反。")]),t._v(" "),n("h3",{attrs:{id:"同名成员的访问"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#同名成员的访问"}},[t._v("#")]),t._v(" 同名成员的访问")]),t._v(" "),n("p",[t._v("当在子类中访问父类的同名成员属性，需要在属性名前加上作用域。")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('cout << "Son m_A = " << s.m_A << endl;\n\tcout << "Base m_A = " << s.Base::m_A << endl;\n')])])]),n("p",[t._v("访问同名成员函数，同样也要加上作用域。")]),t._v(" "),n("h3",{attrs:{id:"同名静态成员的处理方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#同名静态成员的处理方式"}},[t._v("#")]),t._v(" 同名静态成员的处理方式")]),t._v(" "),n("p",[t._v("当通过对象访问数据时，在变量前加上作用于即可")]),t._v(" "),n("p",[t._v("通过类名访问时，同样要加上作用域")]),t._v(" "),n("h3",{attrs:{id:"多继承语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多继承语法"}},[t._v("#")]),t._v(" 多继承语法")]),t._v(" "),n("p",[n("code",[t._v("class Son : public Base01, public Base02")])]),t._v(" "),n("p",[t._v("实际开发不建议使用；")]),t._v(" "),n("h3",{attrs:{id:"菱形继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#菱形继承"}},[t._v("#")]),t._v(" 菱形继承")]),t._v(" "),n("p",[t._v("![7164b682f789580286ae089cfef3b07](C:\\Users\\JINSHE~1\\AppData\\Local\\Temp\\WeChat Files\\7164b682f789580286ae089cfef3b07.png)")]),t._v(" "),n("p",[t._v("利用虚继承，解决菱形继承的重复继承问题")]),t._v(" "),n("p",[t._v("加上virtual关键字， "),n("code",[t._v("virtual public Base{}")])]),t._v(" "),n("p",[t._v("底层原理：生成一个vbptr的指针，通过内存偏移量找到对应的数据。")]),t._v(" "),n("h2",{attrs:{id:"多态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[t._v("#")]),t._v(" 多态")]),t._v(" "),n("h3",{attrs:{id:"多态分为两类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多态分为两类"}},[t._v("#")]),t._v(" 多态分为两类：")]),t._v(" "),n("ul",[n("li",[t._v("静态多态：函数重载，运算符重载")]),t._v(" "),n("li",[t._v("动态多态：派生类和虚函数实现运行时多态")])]),t._v(" "),n("p",[t._v("区别")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("静态多态的函数地址早绑定 - 编译阶段确定函数地址")])]),t._v(" "),n("li",[n("p",[t._v("动态多态的函数地址晚绑定 - 运行阶段确定函数地址")])]),t._v(" "),n("li",[n("p",[t._v("语法：")])])]),t._v(" "),n("p",[t._v("在父类的成员函数前加入 virtual 关键字 ， 实现函数地址的玩绑定")]),t._v(" "),n("p",[t._v("在子类中重写虚函数")]),t._v(" "),n("ul",[n("li",[t._v("实现：")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class Animal {\npublic:\n\tvirtual void speak() {\n\t\tcout << "动物在说话" << endl;\n\n\t}\n};\n\nclass Cat : public Animal {\n\npublic:\n\tvoid speak() {\n\t\tcout << "小猫在说话" << endl;\n\t}\n\n};\nclass Dog : public Animal {\npublic:\n\tvoid speak() {\n\t\t\t\tcout << "小狗在说话" << endl;\n\t}\n};\n\nvoid doSpeak(Animal& animal) { // Animal & animal = cat 父类的指针可以直接指向子类对象\n\tanimal.speak();\n}\n\nvoid test01() {\n\tCat cat;\n\tdoSpeak(cat);\n\n\tDog dog;\n\tdoSpeak(dog);\n\n}\n')])])]),n("h3",{attrs:{id:"多态的原理剖析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多态的原理剖析"}},[t._v("#")]),t._v(" 多态的原理剖析")]),t._v(" "),n("p",[t._v("当在父类中定义virtual 虚函数是，在父类中添加了一个 vfptr 指针")]),t._v(" "),n("ul",[n("li",[n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('public:\n\tvirtual void speak() {\n\t\tcout << "动物在说话" << endl;\n\t}\n')])])])]),t._v(" "),n("li",[n("p",[t._v("当子类中重写了父类中的虚函数，子类中的虚函数表会替换掉父类中的虚函数表，所以当用父类的引用指向子类对象时，会从子类的虚函数表中找函数的入口地址，发生多态。")])]),t._v(" "),n("li",[n("p",[t._v("作用：满足代码的开闭原则 ，对拓展开放，对修改关闭")])])]),t._v(" "),n("p",[t._v("以下是满足开闭原则的计算器案例：")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class Calculator {\npublic:\n\tint m_Num1;\n\tint m_Num2;\n\n\tvirtual int getResult() {\n\t\treturn 0;\n\t}\n\n};\n\n// 加法计算器\nclass AddCalculator : public Calculator {\npublic:\n\tvirtual int getResult() {\n\t\treturn m_Num1 + m_Num2;\n\t}\n\n};\n\n// 减法计算器\nclass SubCalculator : public Calculator {\npublic:\n\tint getResult() {\n\t\treturn m_Num1 - m_Num2;\n\t}\n\n};\n\n// 乘法计算器\nclass MulCalculator : public Calculator {\npublic:\nint getResult() {\n\t\treturn m_Num1 * m_Num2;\n\t}\n};\n\nvoid test01() {\n\tCalculator* cal = new AddCalculator;\n\tcal->m_Num1 = 10;\n\tcal->m_Num2 = 10;\n\tcout << "10 + 10 = " << cal->getResult() << endl;\n\tdelete cal;\n\tcal = new SubCalculator;\n\tcal->m_Num1 = 10;\n\tcal->m_Num2 = 10;\n\tcout << "10 - 10 = " << cal->getResult() << endl;\n\tdelete cal;\n\tcal = new MulCalculator;\n\tcal->m_Num1 = 10;\n\tcal->m_Num2 = 10;\n\tcout << "10 * 10 = " << cal->getResult() << endl;\n\tdelete cal;\n}\n')])])]),n("h3",{attrs:{id:"纯虚函数和多态类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#纯虚函数和多态类"}},[t._v("#")]),t._v(" 纯虚函数和多态类")]),t._v(" "),n("p",[t._v("在多态中，通常父类函数中的系函数的实现是毫无意义的，必须在子类中实现")]),t._v(" "),n("p",[t._v("因此可以将虚函数改为纯虚函数")]),t._v(" "),n("h4",{attrs:{id:"语法-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#语法-2"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),n("p",[n("code",[t._v("virtual 返回值类型 函数名 （参数列表） = 0；")])]),t._v(" "),n("p",[t._v("当类中有了纯虚函数，这个类也称为抽象类")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class Base {  // 抽象类\npublic:\n\tvirtual void func() = 0; //创建抽象类\n};\nclass Son : public Base {\npublic:\n\tvoid func() {\n\t\tcout << "func函数调用" << endl;\n\t}\n};\nvoid test01() {\n\tBase * base = new Son;\n\tbase->func();\n}\n')])])]),n("h4",{attrs:{id:"制作茶叶案例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#制作茶叶案例"}},[t._v("#")]),t._v(" 制作茶叶案例")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class Base {\npublic:\n\tvirtual void Boil() = 0;\n\n\tvirtual void Brew() = 0;\n\n\tvirtual void PutSomething() = 0;\n\n\tvoid make() {\n\t\tBoil();\n\t\tBrew();\n\t\tPutSomething();\n\t}\n};\n\nclass Coffe : public Base {\npublic:\n\tvoid Boil() {\n\n\t\tcout << "煮农夫山泉" << endl;\n\t}\n\n\tvoid Brew() {\n\t\tcout << "倒入杯中" << endl;\n\t}\n\n\tvoid PutSomething() {\n\t\tcout << "加入糖和牛奶" << endl;\n\t}\n};\n\nvoid doWork(Base* abs) {\n\tabs->make();\t\n}\nvoid test01() {\n\tCoffe c;\n\tdoWork(&c);\n}\n\n')])])]),n("h4",{attrs:{id:"制作电脑案例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#制作电脑案例"}},[t._v("#")]),t._v(" 制作电脑案例")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 案例描述：把每个零件分装成抽象类，并提供不同的厂商生产的不同零件\n// 创建电脑类让电脑工作的函数，并且调用每个零件工作的接口\n\nclass CPU {\npublic:\n\tvirtual void calculate() = 0;\n};\n\nclass VideoCard {\npublic:\n\tvirtual void display() = 0;\n};\n\nclass Memory { \npublic:\n\tvirtual void storage() = 0;\n};\n\n// 电脑的组装\nclass Computer {\npublic:\n\t// 设置电脑类的构造函数 \n\tComputer(CPU * cpu, VideoCard* vc, Memory* mem) {\n\t\tm_cpu = cpu;\n\t\tm_vc = vc;\n\t\tm_mem = mem;\n\t}\n\n\tvoid doWork() {\n\t\tm_cpu->calculate();\n\t\tm_vc->display();\n\t\tm_mem->storage(); \n\t}\nprivate:\n\n\tCPU* m_cpu; \n\tVideoCard* m_vc;\n\tMemory* m_mem;\n}; \n\n\n// intel厂商\n\nclass Intel : public CPU, public VideoCard, public Memory {\n\n\tvoid calculate() {  //在子类中重写纯虚函数\n\t\tcout << "Intel CPU" << endl;\n\t}\n\n\tvoid display(){\n\t\tcout << "Intel VideoCard" << endl;\n\t}\n\tvoid storage() {\n\t\tcout << "Intel Memory" << endl;\n\t}\n\n};\n\n// Lenovo\nclass Lenovo : public CPU, public VideoCard, public Memory {\n\n\tvoid calculate() {\n\t\tcout << "Lenovo CPU" << endl;\n\t}\n\n\tvoid display() {\n\t\tcout << "Lenovo VideoCard" << endl;\n\t}\n\tvoid storage() {\n\t\tcout << "Lenovo Memory" << endl;\n\t}\n\n};\n\nvoid test01() {\n\n\tCPU * intelCpu = new Intel; // 通过父类创建子类对象，使用多态\n\tVideoCard * intelCard = new Intel;\n\tMemory * intelMem = new Intel;\n\tComputer* c1 = new Computer(intelCpu, intelCard, intelMem);\n\tc1->doWork();\n\tdelete c1;\n\n}\n')])])]),n("h2",{attrs:{id:"文件操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文件操作"}},[t._v("#")]),t._v(" 文件操作")]),t._v(" "),n("p",[t._v("程序运行时产生的数据都属于临时数据，程序一旦结束都会被释放")]),t._v(" "),n("p",[t._v("通过文件可以将数据"),n("em",[t._v("永久化")])]),t._v(" "),n("p",[t._v("需要包含头文件 "),n("fstream")],1),t._v(" "),n("p",[t._v("文件分为两种类型")]),t._v(" "),n("ol",[n("li",[t._v("文本文件 - 文件以文本的ASCII码形式存储在计算机中")]),t._v(" "),n("li",[t._v("二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂他们")])]),t._v(" "),n("p",[t._v("操作文件的三大类")]),t._v(" "),n("ul",[n("li",[t._v("ofstream  ： 写文件")]),t._v(" "),n("li",[t._v("ifstream ： 读文件")]),t._v(" "),n("li",[t._v("fstream ： 读写文件")])]),t._v(" "),n("h3",{attrs:{id:"文本文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文本文件"}},[t._v("#")]),t._v(" 文本文件")]),t._v(" "),n("ol",[n("li",[t._v("包含头文件 "),n("code",[t._v("#include<fstream>")])]),t._v(" "),n("li",[t._v("创建流对象 "),n("code",[t._v("fstream ofs")]),t._v(" /  "),n("code",[t._v("ifstream ifs")])]),t._v(" "),n("li",[t._v("打开文件 "),n("code",[t._v('ofs.open("文件路径"，打开方式)')])]),t._v(" "),n("li",[t._v("写数据 "),n("code",[t._v('ofs << "写入的数据"')])]),t._v(" "),n("li",[t._v("关闭文件 "),n("code",[t._v("ofs.close();")])])]),t._v(" "),n("p",[t._v("![fb05a007d2367db23a9c16e0ca23ed6](C:\\Users\\JINSHE~1\\AppData\\Local\\Temp\\WeChat Files\\fb05a007d2367db23a9c16e0ca23ed6.png)")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include<iostream> // 写文件\nusing namespace std;\n#include<fstream>\n\nvoid test01(){\n\n\tofstream ofs;\n\n\tofs.open("test.txt", ios::out);\n\n\tofs << "姓名：张三" << endl;\n\tofs << "性别：男" << endl;\n\tofs << "年龄：18" << endl;\n\n\tofs.close();\n}\n')])])]),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('void test01() { // 读文件\n\tifstream ifs;\n\n\tifs.open("test.txt", ios::in);\n\n\tif (!ifs.is_open()) {\n\t\tcout << "文件打开失败" << endl;\n\t\treturn;\n\t}\n\n\t//读数据\n\tchar buf[1024] = { 0 };\n\twhile (ifs >> buf) {\n\t\tcout << buf << endl;\n\t}\n\tifs.close();\n')])])]),n("h3",{attrs:{id:"二进制文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二进制文件"}},[t._v("#")]),t._v(" 二进制文件")]),t._v(" "),n("p",[t._v("写文件")]),t._v(" "),n("ul",[n("li",[t._v("包含头文件 "),n("code",[t._v("#include <ofstream>")])]),t._v(" "),n("li",[t._v("创建输出流对象并打开文件 "),n("code",[t._v('ofs.write("文件名" , ios::out | ios::binary )')])]),t._v(" "),n("li",[t._v("写文件 "),n("code",[t._v("ofs.write((const char *)&p, sizeof(p));")]),t._v("  //这里的p指创建的对象")]),t._v(" "),n("li",[t._v("关闭文件")])]),t._v(" "),n("p",[t._v("读文件")]),t._v(" "),n("ul",[n("li",[t._v("实在是看不懂，等要用到再回来看看")])])])}),[],!1,null,null,null);n.default=s.exports}}]);